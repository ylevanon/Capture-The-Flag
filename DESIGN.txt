Yoav Levanoni
10/6/2022
CSC 203
Project 1 Design Choices


This document is the design document for project 1. Justifications for moving methods from the Functions class into their respective classes are enumerated here, as well as justifications for why a method has remained in the Functions class. The first method to analyze is the getCurrentImage method. I moved the getCurrentImage method from the Functions class to both the Entity and the Background class. I refactored this method into two separate methods for the following reason: getCurrentImage originally takes in an Object as it’s argument and within the logic checks if the Object is an instance of an Entity class or Background Class. Instead of having a procedural method that takes in the target as data, I refactored the getCurrentImage into a method that goes into both target classes and returns the image of itself. I chose to keep the new getCurrentImage methods public, as they are accessed in methods located in the WorldModel class for the Entity case and the WorldView class for the Background case.
The next method I would like to cover is the executeActivity method. I refactored executeActivity from the Functions class to the Action class. My reasoning for this design choice was that the Action class had the actionKind kind instance variable, which controlled the logic in the executeActivity method for the entities action and animation. I kept this method public because it was essential for the VirtualWorld class to draw the entities correctly in the simulation.
The next methods to cover from the Functions class were the transformFull and transformNotFull methods. These methods were easily identifiable for me to move to the Entity class because of the method names and parameters, which imply the state of an instance of a logger regarding how much wood that instance currently has. The method takes an instance of a logger and transforms the logger into the opposite state of which they are in. The removeEntity and addEntity method further validates this hypothesis. I turned both to private, since they are only called within the Entity class for the executeDudeNotFullActivity method and the executeDudeFullActivity method.
The addEntity method was also another method of interest. At first glance, it looked like it could be a constructor method within the Entity class, but I concluded that it belonged to the WorldModel class after reading the arguments and analyzing the methods that depended on it. The reason for moving it from the Functions class to the WorldModel class made sense to me by reading the description for WorldModel and understanding that all the entities in the model are essentially attributes/variables of the WorldModel, “/**Represents the 2D World in which this simulation is running. Keeps track of the size of the world, the background image for each location in the world, and the entities that populate the world. */”.  The method addEntity was kept public as it was used in the Entity class.
The nextPosition format of methods all were refactored from Functions class to the Entity class. This logically makes sense, as an instance of an Entity has a position, and to change its position and move around the world, it would need a method to calculate its next position. These methods were turned to private methods as they only work on the instance variables and are not used outside of the Entity class.
The withinBounds method was refactored into the WorldModel class. This was a simple decision as withinBounds is used as a helper function for methods such as addEntity and removeEntity, which are all methods of WorldModel. The withinBounds method was turned private because it was only utilized as helper method within the WorldModel class and should not be accessed by the other classes.
The shift method was refactored from the Functions class to the Viewport class. This was an easy decision as the shift method originally only took the Viewport, col, and row parameters, so I knew quickly that this method belonged to the Viewport class since the other arguments, col and row, were primitive type ints. The method remained public because it is utilized in the WorldView class method shiftView, which I also refactored from the Functions class. I refactored this method into WorldView because the WorldView is the class responsible for the users view of the virtual world.
Another important method I refactored from the Functions class was the executeAction method, which I placed in the Action class. The two parameters originally in the method were an Action and an EventScheduler. Since I had placed the executeActivityAction and executeAnimationAction into the Action class, and the executeAction method utilizes these two methods, I understood that it belonged to the Action class. In addition, the name was good validation that the Action class would be doing its job, which is performing an action.
The last method of note that I refactored was the scheduleAction method, which I put in the Entity class. The main reason I chose this design was because I thought about the method in this abstract way: What object in my program would need to schedule actions? While the EventScheduler at first seemed the logical choice by name, it was the first parameter Entity that made me understand that the method belongs to the entity, as it would know which actions are its own and when to schedule them!
The only methods I left in the Functions class were the loadImages, processImageLine, getImages, and setAlpha methods. These were the only methods that I could not find an appropriate class to move them into based on their arguments and dependencies. One could argue that they could belong in their own class, maybe named PreProcess, which would conduct the preprocessing steps for executing the virtual world.


